
#include "TorWatch.hpp"
#include "ProcessWatch.hpp"
#include <onions-common/Log.hpp>
#include <botan/botan.h>
#include <thread>
#include <fstream>
#include <sys/wait.h>


int main(int argc, char* argv[])
{
  if (argc < 13)
  {
    std::cerr << "Not enough arguments! Expected many arguments for Tor as "
                 "generated by the Tor Browser.\n";
    return EXIT_FAILURE;
  }

  Log::setLogPath("TorBrowser/OnioNS/launch.log");

  pid_t torP = ProcessWatch::launchTor(argv);
  TorWatch::prepareTor();
  pid_t ocP = ProcessWatch::launchOnioNS(torP);
  pid_t stemP = ProcessWatch::launchStem();

  TorWatch::waitForTorDeath(torP);

  // kill children
  kill(ocP, SIGTERM);
  kill(stemP, SIGTERM);
}



void TorWatch::waitForTorDeath(pid_t p)
{  // adapted from wait's manpage

  int status;
  do
  {
    pid_t w = waitpid(p, &status, WUNTRACED | WCONTINUED);
    if (w == -1)
    {
      perror("waitpid");
      exit(EXIT_FAILURE);
    }

    if (WIFEXITED(status))
      Log::get().notice("Tor exited, status= " +
                        std::to_string(WEXITSTATUS(status)));
    else if (WIFSIGNALED(status))
      Log::get().notice("Tor killed by signal " +
                        std::to_string(WTERMSIG(status)));
    else if (WIFSTOPPED(status))
      Log::get().notice("Tor stopped by signal " +
                        std::to_string(WSTOPSIG(status)));
    else if (WIFCONTINUED(status))
      Log::get().notice("Tor continued");
  } while (!WIFEXITED(status) && !WIFSIGNALED(status));
}



void TorWatch::prepareTor()
{
  using boost::asio::ip::tcp;
  boost::asio::io_service io;
  boost::asio::ip::tcp::socket socket(io);
  tcp::resolver resolver(io);
  tcp::resolver::query query("127.0.0.1", "9151");
  tcp::resolver::iterator iterator = resolver.resolve(query);
  boost::asio::connect(socket, iterator);

  authenticateToTor(socket);
  waitUntilBootstrapped(socket);
  // authenticateQuorum(socket);
}



void TorWatch::authenticateToTor(boost::asio::ip::tcp::socket& socket)
{
  std::string hash = getCookieHash(getCookiePath(socket));
  const char* msg = std::string("AUTHENTICATE " + hash + "\r\n\0").c_str();

  boost::asio::write(socket, boost::asio::buffer(std::string(msg)));

  // read from socket until newline
  boost::asio::streambuf buffer;
  boost::asio::read_until(socket, buffer, "\n");
  std::string response = toString(buffer);

  if (response != "250 OK\r\n")
  {
    Log::get().notice("Tor replied: " + response);
    Log::get().warn("Unexpected answer from Tor!");
    exit(1);
  }
}



void TorWatch::waitUntilBootstrapped(boost::asio::ip::tcp::socket& socket)
{
  std::string response;
  const std::string readyState = "BOOTSTRAP PROGRESS=100";

  while (response.find(readyState) == std::string::npos)
  {
    std::this_thread::sleep_for(std::chrono::milliseconds(500));

    // this c-string to std::string is necessary, otherwise the \0 confuses Tor
    const char* msg = "GETINFO status/bootstrap-phase\r\n\0";
    boost::asio::write(socket, boost::asio::buffer(std::string(msg)));

    // read from socket until newline
    boost::asio::streambuf buffer;
    boost::asio::read_until(socket, buffer, "\n");
    response = toString(buffer);

    Log::get().notice(response);
  }
}


/*
void TorWatch::authenticateQuorum(boost::asio::ip::tcp::socket& socket)
{
  const char* msg = std::string(
                        "SETCONF HidServAuth=\"onions55e7yam27n.onion "
                        "6LCem/8VJIBoFs5Ct94VpQ\"\r\nSAVECONF\r\n\0").c_str();

  boost::asio::write(socket, boost::asio::buffer(std::string(msg)));

  // read from socket until newline
  boost::asio::streambuf buffer;
  boost::asio::read_until(socket, buffer, "\n");
  std::string response = toString(buffer);

  if (response != "250 OK\r\n250 OK\r\n")
  {
    Log::get().notice("Tor replied: " + response);
    Log::get().warn("Unexpected answer from Tor!");
    exit(1);
  }
}*/



std::string TorWatch::getCookieHash(const std::string& path)
{  // https://stackoverflow.com/questions/2602013/
  std::fstream authFile(path);

  if (!authFile)
  {
    Log::get().warn("Unable to open cookie file!");
    exit(1);
  }

  std::string authBin((std::istreambuf_iterator<char>(authFile)),
                      std::istreambuf_iterator<char>());

  Botan::Pipe encode(new Botan::Hex_Encoder);
  encode.process_msg(authBin);
  return encode.read_all_as_string(0);
}



std::string TorWatch::getCookiePath(boost::asio::ip::tcp::socket& socket)
{
  const char* msg = "protocolinfo\r\n\0";
  boost::asio::write(socket, boost::asio::buffer(std::string(msg)));

  // read from socket until newline
  boost::asio::streambuf buffer;
  boost::asio::read_until(socket, buffer, "\n");
  std::string response = toString(buffer);

  Log::get().notice(response);

  std::string needle = "COOKIEFILE=";
  std::size_t pos = response.find(needle);
  if (pos == std::string::npos)
  {
    Log::get().warn("Unexpected response from Tor!");
    exit(1);
  }

  std::size_t pathBegin = pos + needle.size() + 1;
  std::size_t pathEnd = response.find("\"", pathBegin);
  return response.substr(pathBegin, pathEnd - pathBegin);
}



std::string TorWatch::toString(boost::asio::streambuf& buffer)
{
  std::istream is(&buffer);
  return std::string((std::istreambuf_iterator<char>(is)),
                     std::istreambuf_iterator<char>());
}
