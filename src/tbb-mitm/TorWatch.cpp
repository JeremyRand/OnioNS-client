
#include "TorWatch.hpp"
#include "ProcessWatch.hpp"
#include <botan/botan.h>
#include <chrono>
#include <thread>
#include <fstream>
#include <sys/wait.h>


int main(int argc, char* argv[])
{
  if (argc < 15)
  {
    std::cerr << "Not enough arguments! Expected many arguments for Tor as "
                 "generated by the Tor Browser.\n";
    return EXIT_FAILURE;
  }

  // start Tor
  std::cout << "Launching Tor..." << std::endl;
  argv[0] = const_cast<char*>("TorBrowser/Tor/torbin");
  pid_t torP = ProcessWatch::startProcess(argv);

  // wait for Tor's control port to be available
  while (!ProcessWatch::isOpen(9151))
  {
    // https://stackoverflow.com/questions/5278582
    if (waitpid(torP, NULL, WNOHANG) != 0)  // test for existence of Tor
      return EXIT_FAILURE;  // if the Tor Browser was closed, then quit
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
  }

  TorWatch::waitForTorSOCKS();

  // start the onions-client executable
  std::cout << "Launching OnioNS client software..." << std::endl;
  pid_t ocP =
      ProcessWatch::startProcess(ProcessWatch::getOnionsClientProcess());

  // wait until onions-client has established a connection
  while (!ProcessWatch::isOpen(9053))
  {
    if (waitpid(torP, NULL, WNOHANG) != 0 || waitpid(ocP, NULL, WNOHANG) != 0)
    {
      // kill children
      kill(torP, SIGQUIT);
      kill(ocP, SIGQUIT);

      return EXIT_FAILURE;
    }

    std::this_thread::sleep_for(std::chrono::milliseconds(500));
  }

  // launch the Stem script
  std::cout << "Launching OnioNS-TBB software..." << std::endl;
  pid_t stemP = ProcessWatch::startProcess(ProcessWatch::getStemProcess());

  wait(&torP);  // wait for Tor to exit

  // kill children
  kill(ocP, SIGQUIT);
  kill(stemP, SIGQUIT);
}



void TorWatch::waitForTorSOCKS()
{
  using boost::asio::ip::tcp;
  boost::asio::io_service io;
  boost::asio::ip::tcp::socket socket(io);
  tcp::resolver resolver(io);
  tcp::resolver::query query("127.0.0.1", "9151");
  tcp::resolver::iterator iterator = resolver.resolve(query);
  boost::asio::connect(socket, iterator);

  authenticateToTor(socket);
  waitUntilBootstrapped(socket);
}



void TorWatch::authenticateToTor(boost::asio::ip::tcp::socket& socket)
{
  boost::asio::write(
      socket, boost::asio::buffer("AUTHENTICATE " + getCookieHash() + "\n"));

  // read from socket until newline
  boost::asio::streambuf buffer;
  boost::asio::read_until(socket, buffer, "\n");

  // convert to string
  std::istream is(&buffer);
  std::string str((std::istreambuf_iterator<char>(is)),
                  std::istreambuf_iterator<char>());

  std::cout << "***" << str << "***" << std::endl;
}



void TorWatch::waitUntilBootstrapped(boost::asio::ip::tcp::socket& socket)
{
  boost::asio::write(socket,
                     boost::asio::buffer("GETINFO status/bootstrap-phase\n"));

  // read from socket until newline
  boost::asio::streambuf buffer2;
  boost::asio::read_until(socket, buffer2, "\n");

  // convert to string
  std::istream is2(&buffer2);
  std::string str2((std::istreambuf_iterator<char>(is2)),
                   std::istreambuf_iterator<char>());

  std::cout << "***" << str2 << "***" << std::endl;
}



std::string TorWatch::getCookieHash()
{  // https://stackoverflow.com/questions/2602013/
  std::fstream authFile(
      "/home/jesse/tor-browser_en-US/Browser/TorBrowser/Data/Tor/"
      "control_auth_cookie");

  if (!authFile)
    return "";

  std::string authBin((std::istreambuf_iterator<char>(authFile)),
                      std::istreambuf_iterator<char>());

  Botan::Pipe encode(new Botan::Hex_Encoder);
  encode.process_msg(authBin);
  return encode.read_all_as_string(0);
}
